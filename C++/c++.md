# C++程序设计教程  个人笔记

## 第5章 函数

### 含默认参数的函数

* 当又有声明又有定义的时候，定义中不允许有默认参数
* 当有多个形参的时候，有默认值的参数必须放在无默认值的参数后面

## 第6章 程序结构

### 静态储存类型

* 静态全局变量和静态函数不能被其他源文件所调用，即使使用`extern`声明也不行
* 静态变量避免了大工程中源文件之间的变量名称冲突

### 可见性

* 如果在块作用域中使用被隐藏的全局变量，使用`::`来引用该全局变量

### 生命周期

程序的内存空间：

* 代码区：存放程序的代码
* 全局数据区：存放程序中的全局数据和静态数据
* 堆区：存放程序的动态数据
* 栈区：存放程序的局部数据

### 预编译处理

* `#include <文件名>` :  用于嵌入C++提供的头文件，一般存放在C++系统目录中的include子目录下

* `#include "文件名"` : 适合于规定自己建立的头文件

## 第8章 指针

* 指针用于数组，作为函数参数，用于内存访问和堆内存操作。

* 用`&`操作符可以获取变量的地址，指针用于存放地址。

* `*`放在可执行语句中的指针前面，为**间接引用操作符**，可以获取该指针指向的变量内容；

  `*`放在指针定义中时，为**指针定义符**。

* 指针的类型于它指向的实际存储类型要一致。

* 数组名是**指针常量**，区别于指针变量，给数组名赋值是错误的，数组名表示内存中分配了数组的固定位置，修改了这个数组名，就会丢失数组空间。

* 指针常量不是左值，所以不能对指针常量进行运算。





## C++核心编程：面向对象

### 1 内存分区模型

#### **程序的内存空间：**

* 代码区：存放程序的二进制代码，*特点*：**共享**、**只读**
* 全局数据区：存放程序中的全局数据、静态数据和常亮，*特点*：该区域的数据程序结束之后由**操作系统**释放
* 堆区：存放程序的动态数据，由**程序员**分配和释放，在C++中主要利用`new`在堆区<u>开辟内存</u>  ，利用`delete`<u>释放内存</u>
* 栈区：存放程序的局部数据、函数的参数值（形参），由**编译器**自动分配释放，*注意事项*：不要返回局部变量的地址

**意义：不同的区域存放的数据，具有不同的生命周期**

#### `new`

* 在堆区创建整形数据  `new int(10);` // 10代表内存上的数据为10
  * new返回是: 该数据类型的**地址**  `int * p = new int(10);`
* 在堆区利用new开辟数组  `int * arr = new int [10];`  // 10代表数组有10个元素
  * 释放堆区数组： `delete [] arr;`  // 释放数组的时候要加一个[]

### 2 引用

**引用：**给变量起别名

**语法**： `数据类型 &别名 = 原名;`

#### **注意事项**：

* 引用必须初始化； `int  &b;` ×       `int & b = a;`  √
* 引用一旦初始化之后，就不可以修改。

#### **引用做函数参数**：

> 函数参数传递方式： 
>
> * 值传递，形参不会更改实参
> * 地址传递（指针传递），形参会更改实参
> * 引用传递，形参会更改实参

* 作用：函数传参时，可以利用引用的技术让形参修饰实参；
* 优点：可以简化指针修改实参。

通过引用参数产生的效果和按地址传递是一样的，但是引用的语法更清楚简单。

#### **引用做函数的返回值**：

* 不要返回局部变量的引用，因为局部变量存放在栈区
* 函数的调用可以作为左值

#### **引用的本质：**

引用的本质在c++ 内部实现是一个**指针常量**

#### **常量引用：**

使用场景：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加`const`修饰形参，防止形参改变实参



### 3 函数提高

#### **函数默认参数**：

语法： `返回值类型  函数名  （参数  =  默认值） {   }`

注意事项：

* 如果某个位置已经有了默认参数，那么从这个位置往后，从左往右都必须有默认值
* 如果函数声明有默认参数，函数定义的时候就**不能**有默认参数，声明和定义只能有一个有默认参数！

#### **函数占位参数：**

函数形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

语法： `返回值类型  函数名 （数据类型） {    }`

#### **函数重载：**

作用：函数名可以相同，提高复用性

函数重载满足条件：

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**

注意: 函数的返回值不可以作为函数重载的条件

函数重载注意事项：

- 引用作为重载条件
- 函数重载碰到函数默认参数



### 4 类与对象

C++面向对象的三大特性为：**封装**、**继承**、**多态**

C++认为**万事万物都皆为对象**，对象上有其属性和行为

#### 封装：

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

**封装意义一：**

 在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{ 访问权限： 属性 / 行为 };`

**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. `public` 公共权限
2. `protected` 保护权限
3. `private` 私有权限

####  struct和class区别

在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

- struct 默认权限为公共
- class 默认权限为私有

####  成员属性设置为私有

**优点1：**将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性

####  对象的初始化和清理

**构造函数和析构函数：**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号 ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

 **构造函数的分类及调用**
两种分类方式：

-  按参数分为： 有参构造和无参构造

-  按类型分为： 普通构造和拷贝构造（传入一个对象）


三种调用方式：

-  括号法（常用）	`Person p1(10);`

-  显示法                   `Person p2  =  Person(10);`       `Person p3 = Person(p2);`

-  隐式转换法           `Person p4 = 10;`   // Person p4 = Person(10);           `Person p5 = p4;`    // Person p5 = Person(p4); 

